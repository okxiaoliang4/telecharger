"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});function S(t){return fetch(t,{method:"HEAD"}).then(e=>Number(e.headers.get("Content-Length")))}async function*M(t,e,r){const n=new Set;async function i(){const[c,o]=await Promise.race(n);return n.delete(c),o}for(const c of e){const o=(async()=>await r(c,e))().then(a=>[o,a]);n.add(o),n.size>=t&&(yield await i())}for(;n.size;)yield await i()}async function P(t,e){const r=await fetch(t.url,{signal:e.signal,headers:{Range:`bytes=${t.head}-${t.end}`}}),n=r.body.getReader(),i=r.headers.get("content-type")||"application/octet-stream";for(;;){const{done:c,value:o}=await n.read();if(c){const a=new Blob([t.buffer],{type:i});return t.done(a),t}t.append(o)}}function b(t){return{all:t=t||new Map,on:function(e,r){var n=t.get(e);n?n.push(r):t.set(e,[r])},off:function(e,r){var n=t.get(e);n&&(r?n.splice(n.indexOf(r)>>>0,1):t.set(e,[]))},emit:function(e,r){var n=t.get(e);n&&n.slice().map(function(i){i(r)}),(n=t.get("*"))&&n.slice().map(function(i){i(e,r)})}}}class L{constructor(e){this.blob=null,this.url=e.url,this.index=e.index,this.start=e.start,this.head=e.start,this.end=e.end,this.buffer=new Uint8Array(this.size),this.emitter=b()}get progress(){return(this.head-this.start)/this.size}get size(){return this.end-this.start+1}append(e){this.buffer.set(e,this.head-this.start),this.head+=e.length,this.emitter.emit("progress",this.progress)}done(e){this.blob=e}}async function y(t,e={}){const r=b(),{threads:n=8,chunkSize:i=1024e4,immediate:c=!0}=e,o=await S(t),a=Math.ceil(o/i),d=new Array(a),m=new Set;for(let s=0;s<a;s++){let g=s*i,z=s+1==a?o-1:(s+1)*i-1;const u=new L({url:t,index:s,start:g,end:z});u.emitter.on("progress",A=>{const p=d.reduce((x,C)=>x+C.progress,0)/a;r.emit("progress",p),p>=1&&r.all.delete("progress"),A>=1&&u.emitter.all.delete("progress")}),d[s]=u,m.add(u)}let l="init",h;async function f(){if(!(l==="pending"||l==="done")){h=new AbortController,l="pending";try{for await(const s of M(n,Array.from(m),g=>P(g,h)))s.emitter.emit("done",s),s.emitter.all.delete("done");l="done",r.emit("done",new Blob(d.map(s=>s.blob),{type:d[0].blob.type})),r.all.delete("done")}catch(s){s.name==="AbortError"&&(l="pausing")}}}c&&f();function w(){l="pausing",h.abort()}function v(){f()}return{chunks:d,emitter:r,start:f,pause:w,resume:v}}exports.default=y;exports.telecharger=y;
